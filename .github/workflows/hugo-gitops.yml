name: Hugo GitOps Pipeline

on:
  workflow_call:
    inputs:
      registry:
        description: 'Container registry URL'
        required: true
        type: string
      image_name:
        description: 'Image name (without registry)'
        required: true
        type: string
      project_config:
        description: 'Path to project.json config file'
        required: false
        type: string
        default: 'project.json'

    secrets:
      REGISTRY_USERNAME:
        required: true
      REGISTRY_PASSWORD:
        required: true
      GITOPS_APP_ID:
        required: true
      GITOPS_APP_PRIVATE_KEY:
        required: true

env:
  # Fallback images - overridden at runtime from release asset
  BUILDER_IMAGE: ghcr.io/slauger/hugo-gitops-pipeline/builder:latest
  RUNTIME_IMAGE: ghcr.io/slauger/hugo-gitops-pipeline/runtime:latest
  PIPELINE_REPO: slauger/hugo-gitops-pipeline

jobs:
  detect-environment:
    name: Detect Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      hugo_environment: ${{ steps.detect.outputs.hugo_environment }}
      hugo_source: ${{ steps.detect.outputs.hugo_source }}
      baseurl: ${{ steps.detect.outputs.baseurl }}
      output: ${{ steps.detect.outputs.output }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
      gitops_repository: ${{ steps.detect.outputs.gitops_repository }}
      gitops_branch: ${{ steps.detect.outputs.gitops_branch }}
      gitops_file: ${{ steps.detect.outputs.gitops_file }}
      gitops_owner: ${{ steps.detect.outputs.gitops_owner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Detect environment from project.json
        id: detect
        run: |
          CONFIG="${{ inputs.project_config }}"
          REF="${{ github.ref }}"

          if [ ! -f "$CONFIG" ]; then
            echo "::error::Config file $CONFIG not found"
            exit 1
          fi

          # Find matching environment
          RESULT=$(node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('$CONFIG'));
            const ref = '$REF';

            let matched = null;
            for (const [name, env] of Object.entries(config.environments || {})) {
              if (env.when && new RegExp(env.when).test(ref)) {
                matched = { name, ...env };
                break;
              }
            }

            if (matched) {
              // Extract branch slug from ref (e.g., refs/heads/feature/login-page -> login-page)
              const branchName = ref.replace(/^refs\/heads\//, '');
              const branchSlug = branchName.split('/').pop().toLowerCase().replace(/[^a-z0-9]/g, '-');

              // Replace variables in baseurl and gitops file
              const replaceVars = (str) => str
                .replace(/\\\${BRANCH_SLUG}/g, branchSlug)
                .replace(/\\\${BRANCH_NAME}/g, branchName);

              console.log(JSON.stringify({
                environment: matched.name,
                hugo_environment: matched.environment || matched.name,
                hugo_source: config.hugo?.source || 'hugo',
                baseurl: replaceVars(matched.baseurl || ''),
                output: config.output || 'public',
                should_deploy: 'true',
                gitops_repository: matched.gitops?.repository || '',
                gitops_branch: matched.gitops?.branch || 'main',
                gitops_file: replaceVars(matched.gitops?.file || ''),
                gitops_owner: (matched.gitops?.repository || '').split('/')[0] || ''
              }));
            } else {
              console.log(JSON.stringify({
                environment: 'none',
                hugo_environment: 'production',
                hugo_source: config.hugo?.source || 'hugo',
                baseurl: '',
                output: config.output || 'public',
                should_deploy: 'false',
                gitops_repository: '',
                gitops_branch: '',
                gitops_file: '',
                gitops_owner: ''
              }));
            }
          ")

          echo "environment=$(echo $RESULT | jq -r '.environment')" >> $GITHUB_OUTPUT
          echo "hugo_environment=$(echo $RESULT | jq -r '.hugo_environment')" >> $GITHUB_OUTPUT
          echo "hugo_source=$(echo $RESULT | jq -r '.hugo_source')" >> $GITHUB_OUTPUT
          echo "baseurl=$(echo $RESULT | jq -r '.baseurl')" >> $GITHUB_OUTPUT
          echo "output=$(echo $RESULT | jq -r '.output')" >> $GITHUB_OUTPUT
          echo "should_deploy=$(echo $RESULT | jq -r '.should_deploy')" >> $GITHUB_OUTPUT
          echo "gitops_repository=$(echo $RESULT | jq -r '.gitops_repository')" >> $GITHUB_OUTPUT
          echo "gitops_branch=$(echo $RESULT | jq -r '.gitops_branch')" >> $GITHUB_OUTPUT
          echo "gitops_file=$(echo $RESULT | jq -r '.gitops_file')" >> $GITHUB_OUTPUT
          echo "gitops_owner=$(echo $RESULT | jq -r '.gitops_owner')" >> $GITHUB_OUTPUT

      - name: Environment summary
        run: |
          echo "## Environment Detection" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Ref:** \`${{ github.ref }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ steps.detect.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Hugo Environment:** \`${{ steps.detect.outputs.hugo_environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Base URL:** \`${{ steps.detect.outputs.baseurl || '(from Hugo config)' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Should Deploy:** \`${{ steps.detect.outputs.should_deploy }}\`" >> $GITHUB_STEP_SUMMARY

  lint-and-build:
    name: Lint and Build
    runs-on: ubuntu-latest
    needs: detect-environment
    container:
      image: ghcr.io/slauger/hugo-gitops-pipeline/builder:latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Run build phase
        run: run-phase build ${{ inputs.project_config }}
        env:
          CONFIG: ${{ inputs.project_config }}
          ENVIRONMENT: ${{ needs.detect-environment.outputs.hugo_environment }}
          HUGO_SOURCE: ${{ needs.detect-environment.outputs.hugo_source }}
          OUTPUT: ${{ needs.detect-environment.outputs.output }}

      - name: Run lint phase
        run: run-phase lint ${{ inputs.project_config }}
        env:
          CONFIG: ${{ inputs.project_config }}
          HUGO_SOURCE: ${{ needs.detect-environment.outputs.hugo_source }}
          OUTPUT: ${{ needs.detect-environment.outputs.output }}

      - name: Run test phase
        run: run-phase test ${{ inputs.project_config }}
        env:
          CONFIG: ${{ inputs.project_config }}
          HUGO_SOURCE: ${{ needs.detect-environment.outputs.hugo_source }}
          OUTPUT: ${{ needs.detect-environment.outputs.output }}

      - name: Upload build artifact
        uses: actions/upload-artifact@v6
        with:
          name: hugo-public
          path: ${{ needs.detect-environment.outputs.hugo_source }}/${{ needs.detect-environment.outputs.output }}/
          retention-days: 1

  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: [detect-environment, lint-and-build]
    if: needs.detect-environment.outputs.should_deploy == 'true'

    permissions:
      contents: read

    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Resolve pipeline images from release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Download images.json from latest release
          ASSET_URL=$(gh release view --repo ${{ env.PIPELINE_REPO }} --json assets -q '.assets[] | select(.name=="images.json") | .url')

          if [ -n "$ASSET_URL" ]; then
            IMAGES=$(curl -sL -H "Authorization: token $GH_TOKEN" -H "Accept: application/octet-stream" "$ASSET_URL")
            echo "Resolved images from release:"
            echo "$IMAGES" | jq .

            echo "BUILDER_IMAGE=$(echo $IMAGES | jq -r '.builder.full')" >> $GITHUB_ENV
            echo "RUNTIME_IMAGE=$(echo $IMAGES | jq -r '.runtime.full')" >> $GITHUB_ENV
          else
            echo "::warning::No images.json found in release, using fallback (latest)"
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.registry }}/${{ inputs.image_name }}
          tags: |
            type=sha,prefix=${{ needs.detect-environment.outputs.environment }}-,format=short
            type=raw,value=${{ needs.detect-environment.outputs.environment }}-latest

      - name: Generate Dockerfile
        run: |
          cat > Dockerfile.generated <<EOF
          FROM ${{ env.BUILDER_IMAGE }} AS builder
          WORKDIR /build
          COPY . .
          ENV CONFIG=${{ inputs.project_config }}
          ENV ENVIRONMENT=${{ needs.detect-environment.outputs.hugo_environment }}
          ENV HUGO_SOURCE=${{ needs.detect-environment.outputs.hugo_source }}
          ENV OUTPUT=${{ needs.detect-environment.outputs.output }}
          ENV BASEURL=${{ needs.detect-environment.outputs.baseurl }}
          RUN run-phase build ${{ inputs.project_config }}

          FROM ${{ env.RUNTIME_IMAGE }}
          COPY --from=builder /build/${{ needs.detect-environment.outputs.hugo_source }}/${{ needs.detect-environment.outputs.output }} /usr/share/nginx/html
          COPY nginx/ /etc/nginx/conf.d/ 2>/dev/null || true
          EOF

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.generated
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64

      - name: Build summary
        run: |
          echo "## Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ needs.detect-environment.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ inputs.registry }}/${{ inputs.image_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:** \`${{ steps.meta.outputs.tags }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Digest:** \`${{ steps.build.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy via GitOps
    runs-on: ubuntu-latest
    needs: [detect-environment, build-and-push]
    if: needs.detect-environment.outputs.should_deploy == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.GITOPS_APP_ID }}
          private-key: ${{ secrets.GITOPS_APP_PRIVATE_KEY }}
          owner: ${{ needs.detect-environment.outputs.gitops_owner }}
          repositories: ${{ needs.detect-environment.outputs.gitops_repository }}

      - name: Generate gitops-image-replacer config
        run: |
          CONFIG="${{ inputs.project_config }}"

          node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('$CONFIG'));

            const gitopsConfig = {
              'gitops-image-replacer': Object.entries(config.environments || {}).map(([name, env]) => ({
                repository: env.gitops?.repository || '',
                branch: env.gitops?.branch || 'main',
                file: env.gitops?.file || '',
                when: env.when || ''
              })).filter(e => e.repository && e.file)
            };

            fs.writeFileSync('gitops-image-replacer.json', JSON.stringify(gitopsConfig, null, 2));
          "

          cat gitops-image-replacer.json

      - name: Install gitops-image-replacer
        run: pip install gitops-image-replacer==1.1.0

      - name: Update image in GitOps repository
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
          GIT_REF: ${{ github.ref }}
        run: |
          IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
          IMAGE_DIGEST="${{ needs.build-and-push.outputs.image-digest }}"
          IMAGE_FULL="${{ inputs.registry }}/${{ inputs.image_name }}:${IMAGE_TAG}@${IMAGE_DIGEST}"

          echo "Updating image to: ${IMAGE_FULL}"
          gitops-image-replacer --ci --apply "${IMAGE_FULL}"

      - name: Deployment summary
        run: |
          echo "## GitOps Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ needs.detect-environment.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**GitOps Repo:** \`${{ needs.detect-environment.outputs.gitops_repository }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**GitOps File:** \`${{ needs.detect-environment.outputs.gitops_file }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${{ needs.build-and-push.outputs.image-tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Digest:** \`${{ needs.build-and-push.outputs.image-digest }}\`" >> $GITHUB_STEP_SUMMARY
